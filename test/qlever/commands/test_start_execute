import unittest
from unittest.mock import patch, MagicMock, call
from qlever.commands.start import StartCommand


class TestStartCommand(unittest.TestCase):

    @patch('qlever.commands.start.CacheStatsCommand.execute')
    @patch('qlever.commands.stop.StopCommand.execute', return_value=True)
    @patch('qlever.commands.start.run_command')
    @patch('qlever.commands.start.is_qlever_server_alive')
    @patch('subprocess.Popen')
    @patch('qlever.commands.start.Containerize')
    # Tests if killing existing server and restarting a new one works.
    # Also checks the start_command for all the extra options enabled.
    def test_execute_kills_existing_server_on_same_port(self,
                                mock_containerize, mock_popen,
                                mock_is_qlever_server_alive, mock_run_command,
                                mock_stop, mock_cache_stats_command):
        # Setup args
        args = MagicMock()
        args.kill_existing_with_same_port = True
        args.port = 1234
        args.server_binary = "/test/path/server_binary"
        args.name = "TestName"
        args.num_threads = 2
        args.memory_for_queries = "8G"
        args.cache_max_size = "2G"
        args.cache_max_size_single_entry = "124M"
        args.cache_max_num_entries = 1000
        args.system = "native"
        args.show = False
        args.no_warmup = True
        args.timeout = True
        args.access_token = True
        args.only_pso_and_pos_permutations = True
        args.use_patterns = False
        args.use_text_index = "yes"

        # Mock CacheStatsCommand
        mock_cache_stats_command.return_value = None

        # Mock Containerize
        mock_containerize.return_value = None

        # Mock server is not alive initially, then alive after starting
        mock_is_qlever_server_alive.side_effect = [False, True]

        # Mock Popen
        mock_popen.return_value = MagicMock()

        # Instantiate the StartCommand
        sc = StartCommand()

        # Execute the function
        result = sc.execute(args)

        # Assertions
        # Ensure the StopCommand was called
        mock_stop.assert_called_once()
        # Server status should be checked
        mock_is_qlever_server_alive.assert_called()

        # Ensure the server was started
        run_call_1 = f"{args.server_binary} --help"
        start_command = (f"{args.server_binary}"
                        f" -i {args.name}"
                        f" -j {args.num_threads}"
                        f" -p {args.port}"
                        f" -m {args.memory_for_queries}"
                        f" -c {args.cache_max_size}"
                        f" -e {args.cache_max_size_single_entry}"
                        f" -k {args.cache_max_num_entries}"
                        f" -s {args.timeout}"
                        f" -a {args.access_token}"
                        " --only-pso-and-pos-permutations"
                        " --no-patterns"
                        " -t"
                        f" > {args.name}.server-log.txt 2>&1")
        run_call_2 = f"nohup {start_command} &"
        # Assert that run_command was called exactly twice with the
        # correct arguments in order
        mock_run_command.assert_has_calls([call(run_call_1), call(run_call_2)],
                                          any_order=False)
        # Ensure execution was successful
        self.assertTrue(result)


    @patch('qlever.commands.start.run_command')
    @patch('qlever.commands.start.is_qlever_server_alive')
    @patch('qlever.commands.start.Containerize')
    def test_execute_fails_due_to_existing_server(self, mock_containerize,
                                                  mock_is_qlever_server_alive,
                                                  mock_run_command):
        # Setup args
        args = MagicMock()
        args.kill_existing_with_same_port = False
        args.port = 1234
        args.cmdline_regex = f"^ServerMain.* -p {args.port}"
        args.no_containers = True
        args.server_binary = "/test/path/server_binary"
        args.name = "TestName"
        args.num_threads = 2
        args.memory_for_queries = "8G"
        args.cache_max_size = "2G"
        args.cache_max_size_single_entry = "124M"
        args.cache_max_num_entries = 1000
        args.system = "native"
        args.show = False

        # Mock the QLever server as already running
        mock_is_qlever_server_alive.return_value = True

        # Mock Containerize
        mock_containerize.return_value = None

        # Instantiate the StartCommand
        sc = StartCommand()

        # Execute the function
        result = sc.execute(args)

        # Assertions
        # Ensure the server status was checked
        mock_is_qlever_server_alive.assert_called_once_with(args.port)
        # Check that `run_command` was called only for the `--help` check,
        # but not the actual start command
        mock_run_command.assert_called_once_with(
                                                f"{args.server_binary} --help")
        # The function should return False if the server is already running
        self.assertFalse(result)

    @patch('qlever.commands.start.CacheStatsCommand.execute')
    @patch('qlever.commands.start.run_command')
    @patch('qlever.commands.start.is_qlever_server_alive')
    @patch('subprocess.Popen')
    @patch('qlever.commands.start.Containerize')
    @patch('time.sleep')
    def test_execute_successful_server_start(self, mock_sleep,
                                mock_containerize, mock_popen,
                                mock_is_qlever_server_alive, mock_run_command,
                                mock_cache_stats_command):
        # Setup args
        args = MagicMock()
        args.kill_existing_with_same_port = False
        args.port = 1234
        args.server_binary = "/test/path/server_binary"
        args.name = "TestName"
        args.num_threads = 2
        args.memory_for_queries = "8G"
        args.cache_max_size = "2G"
        args.cache_max_size_single_entry = "124M"
        args.cache_max_num_entries = 1000
        args.system = "native"
        args.show = False
        args.no_warmup = True

        # Mock server is not alive initially, then alive after starting
        mock_is_qlever_server_alive.side_effect = [False, True]

        # Mock Popen
        mock_popen.return_value = MagicMock()

        # Mock CacheStatsCommand
        mock_cache_stats_command.return_value = None

        # Mock Containerize
        mock_containerize.return_value = None

        # Mock sleep
        mock_sleep.return_value = None

        # Instantiate the StartCommand
        sc = StartCommand()

        # Execute the function
        result = sc.execute(args)

        # Assertions
        # Server status should be checked
        mock_is_qlever_server_alive.assert_called()
        # Ensure the server was started
        self.assertTrue(mock_run_command.called)
        # Ensure execution was successful
        self.assertTrue(result)

    @patch('qlever.commands.start.CacheStatsCommand.execute')
    @patch('qlever.commands.start.run_command')
    @patch('qlever.commands.start.is_qlever_server_alive')
    @patch('subprocess.Popen')
    @patch('subprocess.run')
    @patch('qlever.commands.start.Containerize')
    def test_execute_server_with_warmup(self, mock_containerize, mock_run,
                                mock_popen, mock_is_qlever_server_alive,
                                mock_run_command, mock_cache_stats_command):
        # Setup args
        args = MagicMock()
        args.kill_existing_with_same_port = False
        args.port = 1234
        args.server_binary = "/test/path/server_binary"
        args.name = "TestName"
        args.num_threads = 2
        args.memory_for_queries = "8G"
        args.cache_max_size = "2G"
        args.cache_max_size_single_entry = "124M"
        args.cache_max_num_entries = 1000
        args.system = "native"
        args.show = False
        args.warmup_cmd = "test_warmup_command"
        args.no_warmup = False

        # Mock Popen
        mock_popen.return_value = MagicMock()

        # Mock CacheStatsCommand
        mock_cache_stats_command.return_value = None

        # Mock Containerize
        mock_containerize.return_value = None

        # Mock that no server is currently running
        mock_is_qlever_server_alive.side_effect = [False, True]

        # Instantiate the StartCommand
        sc = StartCommand()

        # Execute the function
        result = sc.execute(args)

        # Check that Popen was called
        mock_popen.assert_called_once_with(
            f"exec tail -f {args.name}.server-log.txt", shell=True)

        # Check warmup was called
        mock_run.assert_called_once_with(
            args.warmup_cmd, shell=True, check=True)

        # Assertions
        # Ensure the server status was checked
        mock_is_qlever_server_alive.assert_called()
        # Ensure the server was started
        mock_run_command.assert_called()
        # Execution should succeed
        self.assertTrue(result)

    @patch('qlever.commands.start.CacheStatsCommand.execute')
    @patch('qlever.commands.stop.StopCommand.execute', return_value=True)
    @patch('qlever.commands.start.run_command')
    @patch('qlever.commands.start.is_qlever_server_alive')
    @patch('subprocess.Popen')
    @patch('qlever.commands.start.Containerize.supported_systems')
    @patch('qlever.commands.start.run_command_in_container')
    @patch('qlever.commands.start.construct_command_line')
    def test_execute_containerize_and_description(self,
                                mock_construct_cl, mock_run_containerize,
                                mock_containerize, mock_popen,
                                mock_is_qlever_server_alive, mock_run_command,
                                mock_stop, mock_cache_stats_command):
        # Setup args
        args = MagicMock()
        args.kill_existing_with_same_port = True
        args.port = 1234
        args.server_binary = "/test/path/server_binary"
        args.name = "TestName"
        args.num_threads = 2
        args.memory_for_queries = "8G"
        args.cache_max_size = "2G"
        args.cache_max_size_single_entry = "124M"
        args.cache_max_num_entries = 1000
        args.system = "test1"
        args.show = False
        args.description = "TestDescription"
        args.text_description = "TestTextDescription"
        args.access_token = "TestToken"

        # Mock server is not alive initially, then alive after starting
        mock_is_qlever_server_alive.side_effect = [False, True]

        # Mock Popen
        mock_popen.return_value = MagicMock()

        # Mock construct_command_line
        mock_construct_cl.return_value = "TestStart"

        # Mock construct_command_line
        mock_run_containerize.return_value = "TestStart2"

        # mock StopCommand
        mock_stop.return_value = None

        # Mock CacheStatsCommand
        mock_cache_stats_command.return_value = None

        # Mock Containerize
        mock_containerize.return_value = ["test1", "test2"]

        # Instantiate the StartCommand
        sc = StartCommand()

        # Execute the function
        result = sc.execute(args)

        # Assertions
        # check if run_command_in_container is called once
        mock_run_containerize.assert_called_once_with(args, "TestStart")

        # Calls for run command
        run_call_1 = f"{args.system} rm -f {args.server_container}"
        run_call_2 = "TestStart2"
        access_arg = f"--data-urlencode \"access-token={args.access_token}\""
        run_call_3 = (f"curl -Gs http://localhost:{args.port}/api"
                f" --data-urlencode \"index-description={args.description}\""
                f" {access_arg} > /dev/null")
        run_call_4 = (f"curl -Gs http://localhost:{args.port}/api"
                    f" --data-urlencode \"text-description="
                    f"{args.text_description}\""
                    f" {access_arg} > /dev/null")
        # Assert that run_command was called exactly 4 times with the
        # correct arguments in order
        mock_run_command.assert_has_calls([call(run_call_1), call(run_call_2),
                                        call(run_call_3), call(run_call_4)],
                                        any_order=False)
        # Server status should be checked
        mock_is_qlever_server_alive.assert_called()
        # Ensure execution was successful
        self.assertTrue(result)
